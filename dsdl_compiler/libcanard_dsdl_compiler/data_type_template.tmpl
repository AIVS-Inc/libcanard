/*
 * UAVCAN data structure definition for libcanard.
 *
 * Autogenerated, do not edit.
 *
 * Source file: ${t.source_file_path}
 */

#ifndef ${t.include_guard}
#define ${t.include_guard}

#include <stdint.h>
#include "canard.h"

#ifdef __cplusplus
extern "C"
{
#endif

% for inc in t.c_includes:
#include <${inc}>
% endfor


<!--(macro storage_class)-->
 %if t.header_only
static inline
 %else
extern
 %endif
<!--(end)-->

/******************************* Source text **********************************
% for line in t.source_file_text.strip().splitlines():
${line}
% endfor
******************************************************************************/


%if t.fixed_port_id != None:
    %if isinstance(t, ServiceType):
#define ${'%-50s' % (t.macro_name + '_FIXED_SERVICE_ID')} ${t.fixed_port_id}
    %else
#define ${'%-50s' % (t.macro_name + '_FIXED_SUBJECT_ID')} ${t.fixed_port_id}
    %endif

%endif
#define ${'%-50s' % (t.macro_name + '_NAME')} "${t.full_version_name}"

<!--(macro generate_primary_body)--> #! type_name, service, max_bitlen, fields, constants, union, has_array

#define ${'%-50s' % (t.macro_name + service + '_MAX_SIZE')} ((${'%d' % max_bitlen} + 7)/8)

 %if len(constants) > 0:
// Constants
    % for a in constants:
#define ${'%-60s %10s' % (t.macro_name + service + '_' + a.name, a.initialization_expression, )} // ${a.initialization_expression}
    % endfor
 %endif

 %if max_bitlen

    % for a in fields:
        %if isinstance(a.data_type, DynamicArrayType)
#define ${'%-80s' % (t.macro_name + service + '_' + a.name.upper() + '_MAX_LENGTH')} ${a.max_array_elements}
        %elif isinstance(a.data_type, StaticArrayType)
#define ${'%-80s' % (t.macro_name + service + '_' + a.name.upper() + '_LENGTH')} ${a.max_array_elements}  
        %endif
    % endfor

  %if union
typedef enum
{
    % for idx,last,a in enum_last_value(fields):
    ${type_name.upper()}_${a.name.upper()}${',' if not last else ''}
    % endfor
} ${type_name}_ENUM;
  %endif

typedef struct
{
    %if union:
    ${type_name}_ENUM union_tag;        // union_tag indicates what field the data structure is holding

    union
    {
    %endif
  <!--(macro expand_attr_types)--> #! group_name, attrs
    // ${group_name}
    % for a in attrs:
        %if isinstance(a.data_type, ArrayType)
            %if isinstance(a.data_type, DynamicArrayType)
    struct
    {
                %if a.max_array_elements > 255
        ${'uint16_t    %-26s // %s' % (('len;'), 'Dynamic array length')}
                %else
        ${'uint8_t    %-26s // %s' % (('len;'), 'Dynamic array length')}
                %endif
        ${'%-10s %-26s // %s' % ((a.c_type + '*'), ('data;'), a.c_type_comment, )}
    } ${a.name};
            %else
    ${'%-10s %-30s // %s' % (a.c_type, (a.name + a.post_c_type + ';'), a.c_type_comment, )}
            %endif
        %elif isinstance(a.data_type, VoidType):
    // ${a.c_type_comment}
        %else
    ${'%-10s %-30s // %s' % (a.c_type, (a.name + a.post_c_type + ';'), a.c_type_comment, )}
        %endif
    % endfor
  <!--(end)-->
  ${expand_attr_types(group_name='FieldTypes', attrs=fields)}
  %if union:
    };
  %endif
} ${type_name};

@!storage_class!@uint32_t ${type_name}_encode(${type_name}* source, void* msg_buf);
@!storage_class!@int32_t ${type_name}_decode(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf);

@!storage_class!@uint32_t ${type_name}_encode_internal(${type_name}* source, void* msg_buf, uint32_t offset);
@!storage_class!@int32_t ${type_name}_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf, int32_t offset);
 %else
typedef struct
{
    uint8_t empty;
} ${type_name};
@!storage_class!@uint32_t ${type_name}_encode(${type_name}* source, void* msg_buf);
@!storage_class!@int32_t ${type_name}_decode(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf);
@!storage_class!@uint32_t ${type_name}_encode_internal(${type_name}* source, void* msg_buf, uint32_t offset);
@!storage_class!@int32_t ${type_name}_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, ${type_name}* dest, uint8_t** dyn_arr_buf, int32_t offset);

 %endif
<!--(end)-->

% if isinstance(t, ServiceType):

/********************************* Request ***********************************/

${generate_primary_body(type_name=t.name_space_type_name+'Request' + '_' + t.version_name.replace('.', '_'), service='_REQUEST', max_bitlen=t.request_type.bit_length_range.max, \
                               fields=t.request_type.fields, constants=t.request_type.constants, \
                               union=t.request_union, has_array=t.request_has_array)}

/********************************* Response **********************************/

${generate_primary_body(type_name=t.name_space_type_name+'Response' + '_' + t.version_name.replace('.', '_'), service='_RESPONSE', max_bitlen=t.response_type.bit_length_range.max, \
                               fields=t.response_type.fields, constants=t.response_type.constants, \
                               union=t.response_union, has_array=t.response_has_array)}
% else:
${generate_primary_body(type_name=t.name_space_type_name, service='', max_bitlen=t.bit_length_range.max, \
                        fields=t.fields, constants=t.constants, union=t.union, has_array=t.has_array)}
% endif
%if not t.header_only
#ifdef __cplusplus
} // extern "C"
#endif
#endif // ${t.include_guard}
%endif
